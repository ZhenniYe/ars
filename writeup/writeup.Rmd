---
title: "STAT 243 Final Project"
author: "Vincent Myers, Yanting Pan, and Zhenni Ye"
date: "December 10, 2018"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

```{r functioncode, echo=FALSE}

setwd("/Users/yantingpan/Desktop/Adaptive-Rejection-Sampling/ars/R")
source("utils.R")
source("ars.R")
source("checks.R")

```

** Note: Package is under the Github account of Yanting Pan: https://github.com/yantingpan/ars **


## Section 1: Function Overview

Our main function is *ars()*, which requires the user to input a (1) a number of (accepted) samples to generate, and (2) a function that computes the target density; as well as optional inputs for a lower bound and upper bound for the sampling, a center of the distribution, and a step value to assist the function for extremely narrow or wide distributions. 

Below is a demonstration for the function using a gamma distribution.

```{r part1}
set.seed(0)
## custom function for density of gamma distribution
gamma_test <- function(x){
  k <- dgamma(x, shape = 7.5, scale = 1.0)
  return(k)
}

## run ars() function
vals <- ars(10000, gamma_test, l = 0.01, u = 20)

## graph output
z <- seq(0.01, 20, by=0.05)
hist(vals, prob=TRUE, xlab = "", ylab = "", 
     main = "Gamma Distrbution", ylim = c(0, 0.16), xlim = c(0,20))
lines(z, gamma_test(z), type="l", col = "blue", lwd = 2)

```


## Section 2: Algorithm

### Initialization

If the boundary is specified, we will use it as the starting abscissae. Elsewise, we find the abscissaes starting from the center of function. We assume the center is 0, and find the abscissae by checking derivative points with gap, 0.5. 

There are 4 cases of input boundary:

* finite upper and lower bound: use them as starting abscissaes
* infinite lower *l* bound but finite upper bound *u*: 
  + if *u* < 0, find the left nearest point from *u* whose derivitaive is postive
  + otherwise, find the left nearest point from 0 whose derivitaive is postive
* finite lower *l* bound but infinite upper bound *u*: 
  + if *l* > 0, find the right nearest point from *l* whose derivitaive is negative
  + otherwise, find the right nearest point from 0 whose derivitaive is negative
* infinite lower *l* bound but infinite upper bound *u*: find the left nearest point from 0 whose derivative is postive and the right nearest point from 0 whose derivative is negative as the left and right starting abscissaes

After iterations exceed 50, deigned error message will show up and ask user to input the estimated center of the function that helps to find reasonable starting points. After assigning the value of starting abscissae, we will check whether both points are defined on the function.


### Sampling and Updating

Six sub-functions are involved:  *setParams()*, *calcDeriv()*, *lowerPDF()*, *expPDF()*, *expCDF()*, and *invCDF()*. 

The structure of the functions is:  

  * *ars()*: main function; samples from the CDF of the enveloping function, performs the squeeze test and the envelope test, and either (i) accepts or (ii) rejects and updates the fixed points.
    + *setParams()*: determines the parameters for the enveloping function and specific set of fixed points.  
        - *calcDeriv()*: calculates the derivative of a function at a given point.  
        - *expCDF()*: calculates the piecewise exponential CDF of the enveloping function and returns the parameters. Each line segment in the enveloping log PDF, each in the form of $y = mx + b$, is exponentiated and integrated using the form $(1/m) e^{mx+b}$, and then shifted vertically to create a continuous CDF. The CDF is then normalized, and the parameters used for the shifts and the normalization are returned to be used by other functions.   
    + *lowerPDF()*: calculates the value of the squeezing function for a specified evaluation point.  
    + *expPDF()*: calculates the value of the piecewise exponential enveloping function for a specified evaluation point. For a given x-value, the function finds the related piece of the enveloping log function and calculates the y-value using $y = mx + b$ form. It then exponentiates the result, which is returned.  
    + *invCDF()*: inverts the piecewise exponential CDF of the enveloping function; takes as input a number sampled from the Unif(0,1) distribution, finds the corresponding piece of the enveloping function, and inverts the equation used in the *expCDF()* function in order to return a sample from the CDF.  

Since the *ars()* function does not provide any intermediate output, we've used some of the sub-functions below to demonstrate the code. The code below uses the gamma function above to graphically demonstrate the relationship between the target function and the enveloping function.

```{r part2}
## define function inputs
min <- 0.01
max <- 20
p <- c(2, 4, 10) # define the initial fixed points
xvec <- seq(min, max, by=0.1)
target <- gamma_test(xvec)

## calculate corresponding envelope function
par <- setParams(gamma_test, 0.01, 20, p) # parameters for function
envelope <- expPDF(xvec, p, par$int_x, par$m_p, par$lf_p) # enveloping PDF

## plot log PDFs
plot(xvec, log(target), type='l', xlab="X-Values", ylab="Log Density", 
     main="Log PDF Comparison")
lines(xvec, log(envelope), col="red")
legend("bottomright", legend=c("Envelope", "Target"), 
       col=c("red", "black"), lty=1, cex=0.75)

## plot PDFs
plot(xvec, target, type='l', ylim=c(0,0.3), xlab="X-Values", 
     ylab="Density", main="PDF Comparison")
lines(xvec, envelope, col="red")
legend("topright", legend=c("Envelope", "Target"), 
       col=c("red", "black"), lty=1, cex=0.75)
```

The chart below shows the CDF of the enveloping function shown above.

```{r part3, warning=FALSE}
yvec <- seq(0, 1, by=0.001)
envelope_CDF <- invCDF(yvec, par$int_x, par$m_p, par$b_vec, par$nc, par$shift, par$adj)

plot(envelope_CDF, yvec, type='l', xlab="X-Values", ylab="Cumulative Density",
     main = "Enveloping CDF")
```









## Section 2: Testing











## Section 3: Team Contributions
Vincent is responsible for the algorithm of sampling and updating. Yanting and Zhenni are together responsible for initialization of sampling, in-function checks(input error, log-concave, etc.), tests, and R package. 


## Section 4 : Citations
Gilks, W. R., and P. Wild. "Adaptive Rejection Sampling for Gibbs Sampling". Journal of the Royal Statistical Society. Series C (Applied Statistics) 41.2 (1992): 337-348.




